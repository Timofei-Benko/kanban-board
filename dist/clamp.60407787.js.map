{"version":3,"sources":["js/clamp.js"],"names":["clamp","element","options","self","win","window","opt","useNativeClamp","splitOnChars","animate","truncationChar","truncationHTML","sty","style","originalText","innerHTML","supportsNativeClamp","webkitLineClamp","clampValue","isCSSValue","indexOf","truncationHTMLContainer","document","createElement","computeStyle","elem","prop","getComputedStyle","el","pseudo","getPropertyValue","re","test","replace","arguments","toUpperCase","currentStyle","getMaxLines","height","availHeight","clientHeight","lineHeight","getLineHeight","Math","max","floor","getMaxHeight","clmp","lh","parseInt","slice","splitChar","chunks","lastChunk","getLastChild","lastChild","children","length","Array","prototype","call","pop","nodeValue","parentNode","removeChild","truncate","target","maxHeight","reset","shift","split","applyEllipsis","join","setTimeout","str","clampedText","overflow","textOverflow","webkitBoxOrient","display","$clamp"],"mappings":"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","file":"clamp.60407787.js","sourceRoot":"../source","sourcesContent":["/*!\n* Clamp.js 0.5.1\n*\n* Copyright 2011-2013, Joseph Schmitt http://joe.sh\n* Released under the WTFPL license\n* http://sam.zoy.org/wtfpl/\n*/\n\n(function(){\n    /**\n     * Clamps a text node.\n     * @param {HTMLElement} element. Element containing the text node to clamp.\n     * @param {Object} options. Options to pass to the clamper.\n     */\n    function clamp(element, options) {\n        options = options || {};\n\n        var self = this,\n            win = window,\n            opt = {\n                clamp:              options.clamp || 2,\n                useNativeClamp:     typeof(options.useNativeClamp) != 'undefined' ? options.useNativeClamp : true,\n                splitOnChars:       options.splitOnChars || ['.', '-', '–', '—', ' '], //Split on sentences (periods), hypens, en-dashes, em-dashes, and words (spaces).\n                animate:            options.animate || false,\n                truncationChar:     options.truncationChar || '…',\n                truncationHTML:     options.truncationHTML\n            },\n\n            sty = element.style,\n            originalText = element.innerHTML,\n\n            supportsNativeClamp = typeof(element.style.webkitLineClamp) != 'undefined',\n            clampValue = opt.clamp,\n            isCSSValue = clampValue.indexOf && (clampValue.indexOf('px') > -1 || clampValue.indexOf('em') > -1),\n            truncationHTMLContainer;\n            \n        if (opt.truncationHTML) {\n            truncationHTMLContainer = document.createElement('span');\n            truncationHTMLContainer.innerHTML = opt.truncationHTML;\n        }\n\n\n// UTILITY FUNCTIONS __________________________________________________________\n\n        /**\n         * Return the current style for an element.\n         * @param {HTMLElement} elem The element to compute.\n         * @param {string} prop The style property.\n         * @returns {number}\n         */\n        function computeStyle(elem, prop) {\n            if (!win.getComputedStyle) {\n                win.getComputedStyle = function(el, pseudo) {\n                    this.el = el;\n                    this.getPropertyValue = function(prop) {\n                        var re = /(\\-([a-z]){1})/g;\n                        if (prop == 'float') prop = 'styleFloat';\n                        if (re.test(prop)) {\n                            prop = prop.replace(re, function () {\n                                return arguments[2].toUpperCase();\n                            });\n                        }\n                        return el.currentStyle && el.currentStyle[prop] ? el.currentStyle[prop] : null;\n                    }\n                    return this;\n                }\n            }\n\n            return win.getComputedStyle(elem, null).getPropertyValue(prop);\n        }\n\n        /**\n         * Returns the maximum number of lines of text that should be rendered based\n         * on the current height of the element and the line-height of the text.\n         */\n        function getMaxLines(height) {\n            var availHeight = height || element.clientHeight,\n                lineHeight = getLineHeight(element);\n\n            return Math.max(Math.floor(availHeight/lineHeight), 0);\n        }\n\n        /**\n         * Returns the maximum height a given element should have based on the line-\n         * height of the text and the given clamp value.\n         */\n        function getMaxHeight(clmp) {\n            var lineHeight = getLineHeight(element);\n            return lineHeight * clmp;\n        }\n\n        /**\n         * Returns the line-height of an element as an integer.\n         */\n        function getLineHeight(elem) {\n            var lh = computeStyle(elem, 'line-height');\n            if (lh == 'normal') {\n                // Normal line heights vary from browser to browser. The spec recommends\n                // a value between 1.0 and 1.2 of the font size. Using 1.1 to split the diff.\n                lh = parseInt(computeStyle(elem, 'font-size')) * 1.2;\n            }\n            return parseInt(lh);\n        }\n\n\n// MEAT AND POTATOES (MMMM, POTATOES...) ______________________________________\n        var splitOnChars = opt.splitOnChars.slice(0),\n            splitChar = splitOnChars[0],\n            chunks,\n            lastChunk;\n        \n        /**\n         * Gets an element's last child. That may be another node or a node's contents.\n         */\n        function getLastChild(elem) {\n            //Current element has children, need to go deeper and get last child as a text node\n            if (elem.lastChild.children && elem.lastChild.children.length > 0) {\n                return getLastChild(Array.prototype.slice.call(elem.children).pop());\n            }\n            //This is the absolute last child, a text node, but something's wrong with it. Remove it and keep trying\n            else if (!elem.lastChild || !elem.lastChild.nodeValue || elem.lastChild.nodeValue == '' || elem.lastChild.nodeValue == opt.truncationChar) {\n                elem.lastChild.parentNode.removeChild(elem.lastChild);\n                return getLastChild(element);\n            }\n            //This is the last child we want, return it\n            else {\n                return elem.lastChild;\n            }\n        }\n        \n        /**\n         * Removes one character at a time from the text until its width or\n         * height is beneath the passed-in max param.\n         */\n        function truncate(target, maxHeight) {\n            if (!maxHeight) {return;}\n            \n            /**\n             * Resets global variables.\n             */\n            function reset() {\n                splitOnChars = opt.splitOnChars.slice(0);\n                splitChar = splitOnChars[0];\n                chunks = null;\n                lastChunk = null;\n            }\n            \n            var nodeValue = target.nodeValue.replace(opt.truncationChar, '');\n            \n            //Grab the next chunks\n            if (!chunks) {\n                //If there are more characters to try, grab the next one\n                if (splitOnChars.length > 0) {\n                    splitChar = splitOnChars.shift();\n                }\n                //No characters to chunk by. Go character-by-character\n                else {\n                    splitChar = '';\n                }\n                \n                chunks = nodeValue.split(splitChar);\n            }\n            \n            //If there are chunks left to remove, remove the last one and see if\n            // the nodeValue fits.\n            if (chunks.length > 1) {\n                // console.log('chunks', chunks);\n                lastChunk = chunks.pop();\n                // console.log('lastChunk', lastChunk);\n                applyEllipsis(target, chunks.join(splitChar));\n            }\n            //No more chunks can be removed using this character\n            else {\n                chunks = null;\n            }\n            \n            //Insert the custom HTML before the truncation character\n            if (truncationHTMLContainer) {\n                target.nodeValue = target.nodeValue.replace(opt.truncationChar, '');\n                element.innerHTML = target.nodeValue + ' ' + truncationHTMLContainer.innerHTML + opt.truncationChar;\n            }\n\n            //Search produced valid chunks\n            if (chunks) {\n                //It fits\n                if (element.clientHeight <= maxHeight) {\n                    //There's still more characters to try splitting on, not quite done yet\n                    if (splitOnChars.length >= 0 && splitChar != '') {\n                        applyEllipsis(target, chunks.join(splitChar) + splitChar + lastChunk);\n                        chunks = null;\n                    }\n                    //Finished!\n                    else {\n                        return element.innerHTML;\n                    }\n                }\n            }\n            //No valid chunks produced\n            else {\n                //No valid chunks even when splitting by letter, time to move\n                //on to the next node\n                if (splitChar == '') {\n                    applyEllipsis(target, '');\n                    target = getLastChild(element);\n                    \n                    reset();\n                }\n            }\n            \n            //If you get here it means still too big, let's keep truncating\n            if (opt.animate) {\n                setTimeout(function() {\n                    truncate(target, maxHeight);\n                }, opt.animate === true ? 10 : opt.animate);\n            }\n            else {\n                return truncate(target, maxHeight);\n            }\n        }\n        \n        function applyEllipsis(elem, str) {\n            elem.nodeValue = str + opt.truncationChar;\n        }\n\n\n// CONSTRUCTOR ________________________________________________________________\n\n        if (clampValue == 'auto') {\n            clampValue = getMaxLines();\n        }\n        else if (isCSSValue) {\n            clampValue = getMaxLines(parseInt(clampValue));\n        }\n\n        var clampedText;\n        if (supportsNativeClamp && opt.useNativeClamp) {\n            sty.overflow = 'hidden';\n            sty.textOverflow = 'ellipsis';\n            sty.webkitBoxOrient = 'vertical';\n            sty.display = '-webkit-box';\n            sty.webkitLineClamp = clampValue;\n\n            if (isCSSValue) {\n                sty.height = opt.clamp + 'px';\n            }\n        }\n        else {\n            var height = getMaxHeight(clampValue);\n            if (height <= element.clientHeight) {\n                clampedText = truncate(getLastChild(element), height);\n            }\n        }\n        \n        return {\n            'original': originalText,\n            'clamped': clampedText\n        }\n    }\n\n    window.$clamp = clamp;\n})();"]}